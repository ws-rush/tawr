(function(E,b){typeof exports=="object"&&typeof module<"u"?b(exports,require("react"),require("react/jsx-runtime")):typeof define=="function"&&define.amd?define(["exports","react","react/jsx-runtime"],b):(E=typeof globalThis<"u"?globalThis:E||self,b(E.TawrState={},E.react,E.jsxRuntime))})(this,function(E,b,I){"use strict";/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Fe(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const ze=process.env.NODE_ENV!=="production"?Object.freeze({}):{};process.env.NODE_ENV!=="production"&&Object.freeze([]);const Ye=()=>{},re=Object.assign,Be=Object.prototype.hasOwnProperty,se=(e,t)=>Be.call(e,t),D=Array.isArray,M=e=>G(e)==="[object Map]",qe=e=>G(e)==="[object Set]",ie=e=>typeof e=="function",Ge=e=>typeof e=="string",L=e=>typeof e=="symbol",H=e=>e!==null&&typeof e=="object",Ue=Object.prototype.toString,G=e=>Ue.call(e),Se=e=>G(e).slice(8,-1),Je=e=>G(e)==="[object Object]",oe=e=>Ge(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Qe=(e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))})(e=>e.charAt(0).toUpperCase()+e.slice(1)),R=(e,t)=>!Object.is(e,t);/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function m(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let l;const ce=new WeakSet;class Xe{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,ce.has(this)&&(ce.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||me(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Ve(this),Oe(this);const t=l,n=w;l=this,w=!0;try{return this.fn()}finally{process.env.NODE_ENV!=="production"&&l!==this&&m("Active effect was not restored correctly - this is likely a Vue internal bug."),De(this),l=t,w=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)le(t);this.deps=this.depsTail=void 0,Ve(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?ce.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){ue(this)&&this.run()}get dirty(){return ue(this)}}let ye=0,C,$;function me(e,t=!1){if(e.flags|=8,t){e.next=$,$=e;return}e.next=C,C=e}function ae(){ye++}function fe(){if(--ye>0)return;if($){let t=$;for($=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;C;){let t=C;for(C=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}function Oe(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function De(e){let t,n=e.depsTail,s=n;for(;s;){const r=s.prevDep;s.version===-1?(s===n&&(n=r),le(s),Ze(s)):t=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}e.deps=t,e.depsTail=n}function ue(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Ne(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Ne(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===F))return;e.globalVersion=F;const t=e.dep;if(e.flags|=2,t.version>0&&!e.isSSR&&e.deps&&!ue(e)){e.flags&=-3;return}const n=l,s=w;l=e,w=!0;try{Oe(e);const r=e.fn(e._value);(t.version===0||R(r,e._value))&&(e._value=r,t.version++)}catch(r){throw t.version++,r}finally{l=n,w=s,De(e),e.flags&=-3}}function le(e,t=!1){const{dep:n,prevSub:s,nextSub:r}=e;if(s&&(s.nextSub=r,e.prevSub=void 0),r&&(r.prevSub=s,e.nextSub=void 0),process.env.NODE_ENV!=="production"&&n.subsHead===e&&(n.subsHead=r),n.subs===e&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let i=n.computed.deps;i;i=i.nextDep)le(i,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function Ze(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let w=!0;const xe=[];function Te(){xe.push(w),w=!1}function Re(){const e=xe.pop();w=e===void 0?!0:e}function Ve(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=l;l=void 0;try{t()}finally{l=n}}}let F=0;class ke{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class je{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,process.env.NODE_ENV!=="production"&&(this.subsHead=void 0)}track(t){if(!l||!w||l===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==l)n=this.activeLink=new ke(l,this),l.deps?(n.prevDep=l.depsTail,l.depsTail.nextDep=n,l.depsTail=n):l.deps=l.depsTail=n,Ae(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=l.depsTail,n.nextDep=void 0,l.depsTail.nextDep=n,l.depsTail=n,l.deps===n&&(l.deps=s)}return process.env.NODE_ENV!=="production"&&l.onTrack&&l.onTrack(re({effect:l},t)),n}trigger(t){this.version++,F++,this.notify(t)}notify(t){ae();try{if(process.env.NODE_ENV!=="production")for(let n=this.subsHead;n;n=n.nextSub)n.sub.onTrigger&&!(n.sub.flags&8)&&n.sub.onTrigger(re({effect:n.sub},t));for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{fe()}}}function Ae(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let s=t.deps;s;s=s.nextDep)Ae(s)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),process.env.NODE_ENV!=="production"&&e.dep.subsHead===void 0&&(e.dep.subsHead=e),e.dep.subs=e}}const pe=new WeakMap,V=Symbol(process.env.NODE_ENV!=="production"?"Object iterate":""),de=Symbol(process.env.NODE_ENV!=="production"?"Map keys iterate":""),z=Symbol(process.env.NODE_ENV!=="production"?"Array iterate":"");function _(e,t,n){if(w&&l){let s=pe.get(e);s||pe.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new je),r.map=s,r.key=n),process.env.NODE_ENV!=="production"?r.track({target:e,type:t,key:n}):r.track()}}function N(e,t,n,s,r,i){const o=pe.get(e);if(!o){F++;return}const c=a=>{a&&(process.env.NODE_ENV!=="production"?a.trigger({target:e,type:t,key:n,newValue:s,oldValue:r,oldTarget:i}):a.trigger())};if(ae(),t==="clear")o.forEach(c);else{const a=D(e),p=a&&oe(n);if(a&&n==="length"){const h=Number(s);o.forEach((f,v)=>{(v==="length"||v===z||!L(v)&&v>=h)&&c(f)})}else switch((n!==void 0||o.has(void 0))&&c(o.get(n)),p&&c(o.get(z)),t){case"add":a?p&&c(o.get("length")):(c(o.get(V)),M(e)&&c(o.get(de)));break;case"delete":a||(c(o.get(V)),M(e)&&c(o.get(de)));break;case"set":M(e)&&c(o.get(V));break}}fe()}function P(e){const t=d(e);return t===e?t:(_(t,"iterate",z),S(e)?t:t.map(g))}function he(e){return _(e=d(e),"iterate",z),e}const et={__proto__:null,[Symbol.iterator](){return ve(this,Symbol.iterator,g)},concat(...e){return P(this).concat(...e.map(t=>D(t)?P(t):t))},entries(){return ve(this,"entries",e=>(e[1]=g(e[1]),e))},every(e,t){return O(this,"every",e,t,void 0,arguments)},filter(e,t){return O(this,"filter",e,t,n=>n.map(g),arguments)},find(e,t){return O(this,"find",e,t,g,arguments)},findIndex(e,t){return O(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return O(this,"findLast",e,t,g,arguments)},findLastIndex(e,t){return O(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return O(this,"forEach",e,t,void 0,arguments)},includes(...e){return _e(this,"includes",e)},indexOf(...e){return _e(this,"indexOf",e)},join(e){return P(this).join(e)},lastIndexOf(...e){return _e(this,"lastIndexOf",e)},map(e,t){return O(this,"map",e,t,void 0,arguments)},pop(){return Y(this,"pop")},push(...e){return Y(this,"push",e)},reduce(e,...t){return Ie(this,"reduce",e,t)},reduceRight(e,...t){return Ie(this,"reduceRight",e,t)},shift(){return Y(this,"shift")},some(e,t){return O(this,"some",e,t,void 0,arguments)},splice(...e){return Y(this,"splice",e)},toReversed(){return P(this).toReversed()},toSorted(e){return P(this).toSorted(e)},toSpliced(...e){return P(this).toSpliced(...e)},unshift(...e){return Y(this,"unshift",e)},values(){return ve(this,"values",g)}};function ve(e,t,n){const s=he(e),r=s[t]();return s!==e&&!S(e)&&(r._next=r.next,r.next=()=>{const i=r._next();return i.value&&(i.value=n(i.value)),i}),r}const tt=Array.prototype;function O(e,t,n,s,r,i){const o=he(e),c=o!==e&&!S(e),a=o[t];if(a!==tt[t]){const f=a.apply(e,i);return c?g(f):f}let p=n;o!==e&&(c?p=function(f,v){return n.call(this,g(f),v,e)}:n.length>2&&(p=function(f,v){return n.call(this,f,v,e)}));const h=a.call(o,p,s);return c&&r?r(h):h}function Ie(e,t,n,s){const r=he(e);let i=n;return r!==e&&(S(e)?n.length>3&&(i=function(o,c,a){return n.call(this,o,c,a,e)}):i=function(o,c,a){return n.call(this,o,g(c),a,e)}),r[t](i,...s)}function _e(e,t,n){const s=d(e);_(s,"iterate",z);const r=s[t](...n);return(r===-1||r===!1)&&_t(n[0])?(n[0]=d(n[0]),s[t](...n)):r}function Y(e,t,n=[]){Te(),ae();const s=d(e)[t].apply(e,n);return fe(),Re(),s}const nt=Fe("__proto__,__v_isRef,__isVue"),Me=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(L));function rt(e){L(e)||(e=String(e));const t=d(this);return _(t,"has",e),t.hasOwnProperty(e)}class Pe{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,s){if(n==="__v_skip")return t.__v_skip;const r=this._isReadonly,i=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return i;if(n==="__v_raw")return s===(r?i?dt:He:i?pt:Le).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const o=D(t);if(!r){let a;if(o&&(a=et[n]))return a;if(n==="hasOwnProperty")return rt}const c=Reflect.get(t,n,x(t)?t:s);return(L(n)?Me.has(n):nt(n))||(r||_(t,"get",n),i)?c:x(c)?o&&oe(n)?c:c.value:H(c)?r?Ce(c):be(c):c}}class st extends Pe{constructor(t=!1){super(!1,t)}set(t,n,s,r){let i=t[n];if(!this._isShallow){const a=K(i);if(!S(s)&&!K(s)&&(i=d(i),s=d(s)),!D(t)&&x(i)&&!x(s))return a?!1:(i.value=s,!0)}const o=D(t)&&oe(n)?Number(n)<t.length:se(t,n),c=Reflect.set(t,n,s,x(t)?t:r);return t===d(r)&&(o?R(s,i)&&N(t,"set",n,s,i):N(t,"add",n,s)),c}deleteProperty(t,n){const s=se(t,n),r=t[n],i=Reflect.deleteProperty(t,n);return i&&s&&N(t,"delete",n,void 0,r),i}has(t,n){const s=Reflect.has(t,n);return(!L(n)||!Me.has(n))&&_(t,"has",n),s}ownKeys(t){return _(t,"iterate",D(t)?"length":V),Reflect.ownKeys(t)}}class it extends Pe{constructor(t=!1){super(!0,t)}set(t,n){return process.env.NODE_ENV!=="production"&&m(`Set operation on key "${String(n)}" failed: target is readonly.`,t),!0}deleteProperty(t,n){return process.env.NODE_ENV!=="production"&&m(`Delete operation on key "${String(n)}" failed: target is readonly.`,t),!0}}const ot=new st,ct=new it,ge=e=>e,U=e=>Reflect.getPrototypeOf(e);function at(e,t,n){return function(...s){const r=this.__v_raw,i=d(r),o=M(i),c=e==="entries"||e===Symbol.iterator&&o,a=e==="keys"&&o,p=r[e](...s),h=n?ge:t?we:g;return!t&&_(i,"iterate",a?de:V),{next(){const{value:f,done:v}=p.next();return v?{value:f,done:v}:{value:c?[h(f[0]),h(f[1])]:h(f),done:v}},[Symbol.iterator](){return this}}}}function J(e){return function(...t){if(process.env.NODE_ENV!=="production"){const n=t[0]?`on key "${t[0]}" `:"";m(`${Qe(e)} operation ${n}failed: target is readonly.`,d(this))}return e==="delete"?!1:e==="clear"?void 0:this}}function ft(e,t){const n={get(r){const i=this.__v_raw,o=d(i),c=d(r);e||(R(r,c)&&_(o,"get",r),_(o,"get",c));const{has:a}=U(o),p=t?ge:e?we:g;if(a.call(o,r))return p(i.get(r));if(a.call(o,c))return p(i.get(c));i!==o&&i.get(r)},get size(){const r=this.__v_raw;return!e&&_(d(r),"iterate",V),Reflect.get(r,"size",r)},has(r){const i=this.__v_raw,o=d(i),c=d(r);return e||(R(r,c)&&_(o,"has",r),_(o,"has",c)),r===c?i.has(r):i.has(r)||i.has(c)},forEach(r,i){const o=this,c=o.__v_raw,a=d(c),p=t?ge:e?we:g;return!e&&_(a,"iterate",V),c.forEach((h,f)=>r.call(i,p(h),p(f),o))}};return re(n,e?{add:J("add"),set:J("set"),delete:J("delete"),clear:J("clear")}:{add(r){!t&&!S(r)&&!K(r)&&(r=d(r));const i=d(this);return U(i).has.call(i,r)||(i.add(r),N(i,"add",r,r)),this},set(r,i){!t&&!S(i)&&!K(i)&&(i=d(i));const o=d(this),{has:c,get:a}=U(o);let p=c.call(o,r);p?process.env.NODE_ENV!=="production"&&We(o,c,r):(r=d(r),p=c.call(o,r));const h=a.call(o,r);return o.set(r,i),p?R(i,h)&&N(o,"set",r,i,h):N(o,"add",r,i),this},delete(r){const i=d(this),{has:o,get:c}=U(i);let a=o.call(i,r);a?process.env.NODE_ENV!=="production"&&We(i,o,r):(r=d(r),a=o.call(i,r));const p=c?c.call(i,r):void 0,h=i.delete(r);return a&&N(i,"delete",r,void 0,p),h},clear(){const r=d(this),i=r.size!==0,o=process.env.NODE_ENV!=="production"?M(r)?new Map(r):new Set(r):void 0,c=r.clear();return i&&N(r,"clear",void 0,void 0,o),c}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=at(r,e,t)}),n}function Ke(e,t){const n=ft(e,t);return(s,r,i)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?s:Reflect.get(se(n,r)&&r in s?n:s,r,i)}const ut={get:Ke(!1,!1)},lt={get:Ke(!0,!1)};function We(e,t,n){const s=d(n);if(s!==n&&t.call(e,s)){const r=Se(e);m(`Reactive ${r} contains both the raw and reactive versions of the same object${r==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const Le=new WeakMap,pt=new WeakMap,He=new WeakMap,dt=new WeakMap;function ht(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function vt(e){return e.__v_skip||!Object.isExtensible(e)?0:ht(Se(e))}function be(e){return K(e)?e:$e(e,!1,ot,ut,Le)}function Ce(e){return $e(e,!0,ct,lt,He)}function $e(e,t,n,s,r){if(!H(e))return process.env.NODE_ENV!=="production"&&m(`value cannot be made ${t?"readonly":"reactive"}: ${String(e)}`),e;if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const i=r.get(e);if(i)return i;const o=vt(e);if(o===0)return e;const c=new Proxy(e,o===2?s:n);return r.set(e,c),c}function Q(e){return K(e)?Q(e.__v_raw):!!(e&&e.__v_isReactive)}function K(e){return!!(e&&e.__v_isReadonly)}function S(e){return!!(e&&e.__v_isShallow)}function _t(e){return e?!!e.__v_raw:!1}function d(e){const t=e&&e.__v_raw;return t?d(t):e}const g=e=>H(e)?be(e):e,we=e=>H(e)?Ce(e):e;function x(e){return e?e.__v_isRef===!0:!1}class gt{constructor(t,n,s){this.fn=t,this.setter=n,this._value=void 0,this.dep=new je(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=F-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&l!==this)return me(this,!0),!0;process.env.NODE_ENV}get value(){const t=process.env.NODE_ENV!=="production"?this.dep.track({target:this,type:"get",key:"value"}):this.dep.track();return Ne(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter?this.setter(t):process.env.NODE_ENV!=="production"&&m("Write operation failed: computed value is readonly")}}function bt(e,t,n=!1){let s,r;ie(e)?s=e:(s=e.get,r=e.set);const i=new gt(s,r,n);return process.env.NODE_ENV!=="production"&&t&&!n&&(i.onTrack=t.onTrack,i.onTrigger=t.onTrigger),i}const X={},Z=new WeakMap;let j;function wt(e,t=!1,n=j){if(n){let s=Z.get(n);s||Z.set(n,s=[]),s.push(e)}else process.env.NODE_ENV!=="production"&&!t&&m("onWatcherCleanup() was called when there was no active watcher to associate with.")}function Et(e,t,n=ze){const{immediate:s,deep:r,once:i,scheduler:o,augmentJob:c,call:a}=n,p=u=>{(n.onWarn||m)("Invalid watch source: ",u,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},h=u=>r?u:S(u)||r===!1||r===0?T(u,1):T(u);let f,v,B,k,ee=!1,te=!1;if(x(e)?(v=()=>e.value,ee=S(e)):Q(e)?(v=()=>h(e),ee=!0):D(e)?(te=!0,ee=e.some(u=>Q(u)||S(u)),v=()=>e.map(u=>{if(x(u))return u.value;if(Q(u))return h(u);if(ie(u))return a?a(u,2):u();process.env.NODE_ENV!=="production"&&p(u)})):ie(e)?t?v=a?()=>a(e,2):e:v=()=>{if(B){Te();try{B()}finally{Re()}}const u=j;j=f;try{return a?a(e,3,[k]):e(k)}finally{j=u}}:(v=Ye,process.env.NODE_ENV!=="production"&&p(e)),t&&r){const u=v,y=r===!0?1/0:r;v=()=>T(u(),y)}const W=()=>{f.stop()};if(i&&t){const u=t;t=(...y)=>{u(...y),W()}}let A=te?new Array(e.length).fill(X):X;const q=u=>{if(!(!(f.flags&1)||!f.dirty&&!u))if(t){const y=f.run();if(r||ee||(te?y.some((Ee,ne)=>R(Ee,A[ne])):R(y,A))){B&&B();const Ee=j;j=f;try{const ne=[y,A===X?void 0:te&&A[0]===X?[]:A,k];a?a(t,3,ne):t(...ne),A=y}finally{j=Ee}}}else f.run()};return c&&c(q),f=new Xe(v),f.scheduler=o?()=>o(q,!1):q,k=u=>wt(u,!1,f),B=f.onStop=()=>{const u=Z.get(f);if(u){if(a)a(u,4);else for(const y of u)y();Z.delete(f)}},process.env.NODE_ENV!=="production"&&(f.onTrack=n.onTrack,f.onTrigger=n.onTrigger),t?s?q(!0):A=f.run():o?o(q.bind(null,!0),!0):f.run(),W.pause=f.pause.bind(f),W.resume=f.resume.bind(f),W.stop=W,W}function T(e,t=1/0,n){if(t<=0||!H(e)||e.__v_skip||(n=n||new Set,n.has(e)))return e;if(n.add(e),t--,x(e))T(e.value,t,n);else if(D(e))for(let s=0;s<e.length;s++)T(e[s],t,n);else if(qe(e)||M(e))e.forEach(s=>{T(s,t,n)});else if(Je(e)){for(const s in e)T(e[s],t,n);for(const s of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,s)&&T(e[s],t,n)}return e}function St(e){return e&&typeof e=="object"&&"$state"in e&&"actions"in e}function yt(e,t){const n=new WeakSet,s=(r,i=[])=>typeof r!="object"||r===null||n.has(r)?r:(n.add(r),new Proxy(r,{get(o,c){if(c==="actions")return;const a=[...i,c];t(a);const p=o[c];return typeof p=="function"?p.bind(o):s(p,a)},set(){return!1},deleteProperty(){return!1}}));return s(e)}function mt(e){if(!St(e))throw new Error("useSnapshot requires a store created with defineStore()");const[,t]=b.useState(0),n=b.useRef(new Set),s=b.useRef(!0);b.useEffect(()=>(s.current=!0,()=>{s.current=!1}),[]);const r=i=>{n.current.add(i.join("."))};return b.useEffect(()=>{const i=Array.from(n.current),o=[];return i.forEach(c=>{const a=c.split("."),p=Et(()=>{let h=e;for(const f of a)h=h[f];return h},()=>{s.current&&t(h=>h+1)},{flush:"sync"});o.push(p)}),()=>o.forEach(c=>c())},[e]),n.current=new Set,yt(e,r)}function Ot(e){const t=e.state(),n=be(t),s={$state:n};if(Object.keys(n).forEach(r=>{Object.defineProperty(s,r,{get:()=>n[r],set:i=>{n[r]=i},enumerable:!0})}),e.getters&&Object.entries(e.getters).forEach(([r,i])=>{const o=bt(()=>i(n));Object.defineProperty(s,r,{get:()=>o.value,enumerable:!0})}),e.actions){const r={};Object.entries(e.actions).forEach(([i,o])=>{r[i]=o.bind(s)}),s.actions=r}return s}class Dt extends b.Component{constructor(t){super(t),this.state={error:null}}static getDerivedStateFromError(t){return{error:t}}componentDidCatch(t,n){console.error("Error caught by boundary:",t,n)}render(){return this.state.error?this.props.fallback(this.state.error):this.props.children}}function Nt({resolve:e,children:t}){const n=b.use(e);return I.jsx(I.Fragment,{children:t(n)})}function xt({resolve:e,fallback:t=null,error:n=r=>I.jsxs("div",{children:["Error: ",r.message]}),children:s}){return I.jsx(Dt,{fallback:n,children:I.jsx(b.Suspense,{fallback:t,children:I.jsx(Nt,{resolve:e,children:s})})})}E.Awaitable=xt,E.defineStore=Ot,E.useSnapshot=mt,Object.defineProperty(E,Symbol.toStringTag,{value:"Module"})});
